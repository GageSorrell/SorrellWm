#include "Background.h"
#include "Core/Globals.h"

HBITMAP CapturedBitmap = nullptr;

static LRESULT CALLBACK BlurWindowProcNew(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    std::cout << "Message " << uMsg << std::endl;
    if (uMsg == WM_PAINT)
    {
        std::cout << "Going to PAINT..." << std::endl;
    }
    switch (uMsg)
    {
        case WM_PAINT:
        {
            std::cout << "Received WM_PAINT call." << std::endl;
            PAINTSTRUCT PaintStruct;
            HDC DeviceContext = BeginPaint(hWnd, &PaintStruct);

            std::cout << "Called BeginPaint!" << std::endl;

            HDC MemoryDc = CreateCompatibleDC(DeviceContext);
            HBITMAP OldObject = (HBITMAP) SelectObject(MemoryDc, CapturedBitmap);

            std::cout << "This far" << std::endl;

            BITMAP BitmapInfo;
            GetObject(CapturedBitmap, sizeof(BitmapInfo), &BitmapInfo);
            srand(time(0));

            const int DieRoll = rand() % 2;
            int TempValue = DieRoll == 0 ? 0 : 100;
            BitBlt(
                DeviceContext,
                0,
                0,
                BitmapInfo.bmWidth,
                BitmapInfo.bmHeight,
                MemoryDc,
                0,
                0,
                SRCCOPY
            );

            std::cout << "Copied into window's context." << std::endl;

            SelectObject(MemoryDc, OldObject);
            DeleteDC(MemoryDc);

            std::cout << "Cleaned up copied bitmap." << std::endl;

            EndPaint(hWnd, &PaintStruct);

            std::cout << "Ended paint successfully!" << std::endl;
            return 0;
        }

        case WM_DESTROY:
        {
            return 0;
        }
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

Napi::Value StartBlurOverlayNew(const Napi::CallbackInfo& CallbackInfo)
{
    Napi::Env Environment = CallbackInfo.Env();

    GGlobals::BlurWorker->Handle = GetHandleArgument(Environment, CallbackInfo, 0);
    std::cout << "Going to queue..." << std::endl;
    GGlobals::BlurWorker->Queue();

    return Environment.Undefined();
}

FBlurWorker::FBlurWorker(Napi::Function EmptyCallback) : Napi::AsyncWorker(EmptyCallback)
{ }

void FBlurWorker::Execute()
{
    std::cout << "Statring Execute" << std::endl;
    // RECT windowRect;
    // if (!GetWindowRect(Handle, &windowRect))
    // {
    //     SetError("Failed to get window rectangle.");
    //     return;
    // }

    // Width = windowRect.right - windowRect.left;
    // Height = windowRect.bottom - windowRect.top;

    // HDC screenDC = GetDC(Handle);
    // HDC memoryDC = CreateCompatibleDC(screenDC);
    // HBITMAP bitmap = CreateCompatibleBitmap(screenDC, Width, Height);
    // HGDIOBJ oldObject = SelectObject(memoryDC, bitmap);

    // // // Use PrintWindow to capture the window without shadow effects.
    // // if (!PrintWindow(hwnd, memoryDC, PW_RENDERFULLCONTENT))
    // // {
    // //     SetError("Failed to capture the window using PrintWindow.");
    // //     SelectObject(memoryDC, oldObject);
    // //     DeleteObject(bitmap);
    // //     DeleteDC(memoryDC);
    // //     ReleaseDC(hwnd, screenDC);
    // //     return;
    // // }
    // RECT WindowRect;
    // DwmGetWindowAttribute(Handle, DWMWA_EXTENDED_FRAME_BOUNDS, &WindowRect, sizeof(WindowRect));

    // const int Width = WindowRect.right - WindowRect.left;
    // const int Height = WindowRect.bottom - WindowRect.top;

    // HDC ScreenDC = GetDC(NULL);
    // HDC MemoryDC = CreateCompatibleDC(ScreenDC);
    // HBITMAP CapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
    // HGDIOBJ OldObject = SelectObject(MemoryDC, CapturedBitmap);

    // BOOL Success = BitBlt(
    //     MemoryDC,
    //     0,
    //     0,
    //     Width,
    //     Height,
    //     ScreenDC,
    //     WindowRect.left,
    //     WindowRect.top,
    //     SRCCOPY
    // );
    // if (Success)
    // {
    //     std::cout << "BitBlt SUCCESS" << std::endl;
    // }
    // else
    // {
    //     std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
    // }

    // SelectObject(MemoryDC, OldObject);
    // DeleteDC(MemoryDC);
    // ReleaseDC(Handle, ScreenDC);


    // // HDC ScreenDC = GetDC(NULL);
    // // HDC MemoryDC = CreateCompatibleDC(ScreenDC);
    // // HBITMAP CapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
    // // HGDIOBJ OldObject = SelectObject(MemoryDC, CapturedBitmap);

    // // BOOL Success = BitBlt(
    // //     MemoryDC,
    // //     0,
    // //     0,
    // //     Width,
    // //     Height,
    // //     ScreenDC,
    // //     WindowRect.left,
    // //     WindowRect.top,
    // //     SRCCOPY
    // // );
    // // if (Success)
    // // {
    // //     std::cout << "BitBlt SUCCESS" << std::endl;
    // // }
    // // else
    // // {
    // //     std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
    // // }

    // delete[] CapturedBitmap;

    // SelectObject(memoryDC, oldObject);
    // DeleteDC(memoryDC);
    // ReleaseDC(Handle, screenDC);
    RECT WindowRect;
    DwmGetWindowAttribute(Handle, DWMWA_EXTENDED_FRAME_BOUNDS, &WindowRect, sizeof(WindowRect));

    const int Width = WindowRect.right - WindowRect.left;
    const int Height = WindowRect.bottom - WindowRect.top;

    HDC ScreenDC = GetDC(NULL);
    HDC MemoryDC = CreateCompatibleDC(ScreenDC);
    HBITMAP InCapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
    HGDIOBJ OldObject = SelectObject(MemoryDC, InCapturedBitmap);

    std::cout << "BitBlt of Execute" << std::endl;
    BOOL Success = BitBlt(
        MemoryDC,
        0,
        0,
        Width,
        Height,
        ScreenDC,
        WindowRect.left,
        WindowRect.top,
        SRCCOPY
    );
    if (Success)
    {
        std::cout << "BitBlt SUCCESS" << std::endl;
    }
    else
    {
        std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
    }

    SelectObject(MemoryDC, OldObject);
    DeleteDC(MemoryDC);
    ReleaseDC(Handle, ScreenDC);

    CapturedBitmap = InCapturedBitmap;

    // Create a new window with similar size and position that will display the captured bitmap.
    // The window should not appear on the taskbar or in Alt+Tab, so we use WS_EX_TOOLWINDOW.
    // Also, no icon on the taskbar. WS_POPUP and WS_EX_TOOLWINDOW typically ensure no taskbar entry or Alt+Tab listing.

    HINSTANCE instanceHandle = GetModuleHandle(NULL);
    const char* ClassName = "BlurWindowClassNew";
    const char* WindowName = "SorrellWm Background";
    // std::string className = "";

    static bool classRegistered = false;
    if (!classRegistered)
    {
        WNDCLASS windowClass = { 0 };
        windowClass.lpfnWndProc = BlurWindowProcNew;
        windowClass.hInstance = instanceHandle;
        windowClass.lpszClassName = ClassName;
        RegisterClass(&windowClass);
        classRegistered = true;
    }

    std::cout << "Going to create window..." << std::endl;

    HWND overlayWindow = CreateWindowEx(
        0,
        ClassName,
        WindowName,
        WS_POPUP,
        WindowRect.left,
        WindowRect.top,
        Width,
        Height,
        nullptr,
        nullptr,
        instanceHandle,
        nullptr
    );

    if (overlayWindow == nullptr)
    {
        std::cout << "FAILED to make window" << std::endl;
    }
    else
    {
        std::cout << "Made window" << std::endl;
    }

    ShowWindow(overlayWindow, SW_SHOW);

    std::cout << "Showed window!" << std::endl;
    // Callback().MakeCallback(Receiver().Value(), {Env().Null()});
}

void FBlurWorker::OnOK()
{
    // Napi::HandleScope scope(Env());
}

// void FBlurWorker::Execute()
// {
//     // RECT windowRect;
//     // if (!GetWindowRect(Handle, &windowRect))
//     // {
//     //     SetError("Failed to get window rectangle.");
//     //     return;
//     // }

//     // Width = windowRect.right - windowRect.left;
//     // Height = windowRect.bottom - windowRect.top;

//     // HDC screenDC = GetDC(Handle);
//     // HDC memoryDC = CreateCompatibleDC(screenDC);
//     // HBITMAP bitmap = CreateCompatibleBitmap(screenDC, Width, Height);
//     // HGDIOBJ oldObject = SelectObject(memoryDC, bitmap);

//     // // // Use PrintWindow to capture the window without shadow effects.
//     // // if (!PrintWindow(hwnd, memoryDC, PW_RENDERFULLCONTENT))
//     // // {
//     // //     SetError("Failed to capture the window using PrintWindow.");
//     // //     SelectObject(memoryDC, oldObject);
//     // //     DeleteObject(bitmap);
//     // //     DeleteDC(memoryDC);
//     // //     ReleaseDC(hwnd, screenDC);
//     // //     return;
//     // // }
//     // RECT WindowRect;
//     // DwmGetWindowAttribute(Handle, DWMWA_EXTENDED_FRAME_BOUNDS, &WindowRect, sizeof(WindowRect));

//     // const int Width = WindowRect.right - WindowRect.left;
//     // const int Height = WindowRect.bottom - WindowRect.top;

//     // HDC ScreenDC = GetDC(NULL);
//     // HDC MemoryDC = CreateCompatibleDC(ScreenDC);
//     // HBITMAP CapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
//     // HGDIOBJ OldObject = SelectObject(MemoryDC, CapturedBitmap);

//     // BOOL Success = BitBlt(
//     //     MemoryDC,
//     //     0,
//     //     0,
//     //     Width,
//     //     Height,
//     //     ScreenDC,
//     //     WindowRect.left,
//     //     WindowRect.top,
//     //     SRCCOPY
//     // );
//     // if (Success)
//     // {
//     //     std::cout << "BitBlt SUCCESS" << std::endl;
//     // }
//     // else
//     // {
//     //     std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
//     // }

//     // SelectObject(MemoryDC, OldObject);
//     // DeleteDC(MemoryDC);
//     // ReleaseDC(Handle, ScreenDC);


//     // // HDC ScreenDC = GetDC(NULL);
//     // // HDC MemoryDC = CreateCompatibleDC(ScreenDC);
//     // // HBITMAP CapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
//     // // HGDIOBJ OldObject = SelectObject(MemoryDC, CapturedBitmap);

//     // // BOOL Success = BitBlt(
//     // //     MemoryDC,
//     // //     0,
//     // //     0,
//     // //     Width,
//     // //     Height,
//     // //     ScreenDC,
//     // //     WindowRect.left,
//     // //     WindowRect.top,
//     // //     SRCCOPY
//     // // );
//     // // if (Success)
//     // // {
//     // //     std::cout << "BitBlt SUCCESS" << std::endl;
//     // // }
//     // // else
//     // // {
//     // //     std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
//     // // }

//     // delete[] CapturedBitmap;

//     // SelectObject(memoryDC, oldObject);
//     // DeleteDC(memoryDC);
//     // ReleaseDC(Handle, screenDC);
//     RECT WindowRect;
//     DwmGetWindowAttribute(Handle, DWMWA_EXTENDED_FRAME_BOUNDS, &WindowRect, sizeof(WindowRect));

//     const int Width = WindowRect.right - WindowRect.left;
//     const int Height = WindowRect.bottom - WindowRect.top;

//     HDC ScreenDC = GetDC(NULL);
//     HDC MemoryDC = CreateCompatibleDC(ScreenDC);
//     HBITMAP CapturedBitmap = CreateCompatibleBitmap(ScreenDC, Width, Height);
//     HGDIOBJ OldObject = SelectObject(MemoryDC, CapturedBitmap);

//     BOOL Success = BitBlt(
//         MemoryDC,
//         0,
//         0,
//         Width,
//         Height,
//         ScreenDC,
//         WindowRect.left,
//         WindowRect.top,
//         SRCCOPY
//     );
//     if (Success)
//     {
//         std::cout << "BitBlt SUCCESS" << std::endl;
//     }
//     else
//     {
//         std::cout << "BitBlt Failed" << "\n" << GetLastErrorAsString() << std::endl;
//     }

//     SelectObject(MemoryDC, OldObject);
//     DeleteDC(MemoryDC);
//     ReleaseDC(Handle, ScreenDC);

//     CapturedBitmap = CapturedBitmap;

//     // Create a new window with similar size and position that will display the captured bitmap.
//     // The window should not appear on the taskbar or in Alt+Tab, so we use WS_EX_TOOLWINDOW.
//     // Also, no icon on the taskbar. WS_POPUP and WS_EX_TOOLWINDOW typically ensure no taskbar entry or Alt+Tab listing.

//     HINSTANCE instanceHandle = GetModuleHandle(NULL);
//     const char* ClassName = "BlurWindowClassNew";
//     const char* WindowName = "SorrellWm Background";
//     // std::string className = "";

//     static bool classRegistered = false;
//     if (!classRegistered)
//     {
//         WNDCLASS windowClass = { 0 };
//         windowClass.lpfnWndProc = BlurWindowProcNew;
//         windowClass.hInstance = instanceHandle;
//         windowClass.lpszClassName = ClassName;
//         RegisterClass(&windowClass);
//         classRegistered = true;
//     }

//     HWND overlayWindow = CreateWindowEx(
//         WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_NOACTIVATE,
//         ClassName,
//         WindowName,
//         WS_POPUP,
//         WindowRect.left,
//         WindowRect.top,
//         Width,
//         Height,
//         NULL,
//         NULL,
//         instanceHandle,
//         NULL
//     );

//     ShowWindow(overlayWindow, SW_SHOW);
//     // Callback().MakeCallback(Receiver().Value(), {Env().Null()});
// }

//     void OnOK() override
//     {
//         // Napi::HandleScope scope(Env());
//     }
// private:
//     HWND Handle;
//     int Width;
//     int Height;
// };
